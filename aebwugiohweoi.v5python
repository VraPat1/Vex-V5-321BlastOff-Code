{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nwheelBase = 182.5\ntrackWidth = 260\nwheelTravel = 299.24 \nexternalGearRatio = 0.75 # Input / Output\n\nleft_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nleft_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nleft_motor_c = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b, left_motor_c)\nright_motor_a = Motor(Ports.PORT13, GearSetting.RATIO_6_1, True)\nright_motor_b = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\nright_motor_c = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b, right_motor_c)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, wheelTravel, trackWidth, wheelBase, MM, externalGearRatio)\ncontroller_1 = Controller(PRIMARY)\nmotor_4 = Motor(Ports.PORT4, GearSetting.RATIO_6_1, False)\nmotor_20 = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\"\"\"\nwheelBase = 182.5\ntrackWidth = 260\nwheelTravel = 299.24 \nexternalGearRatio = 0.75 # Input / Output\n\nleft_motor_a = Motor(Ports.PORT3, GearSetting.RATIO_6_1, False)\nleft_motor_b = Motor(Ports.PORT2, GearSetting.RATIO_6_1, False)\nleft_motor_c = Motor(Ports.PORT1, GearSetting.RATIO_6_1, False)\nleft_drive_smart = MotorGroup(left_motor_a, left_motor_b, left_motor_c)\nright_motor_a = Motor(Ports.PORT13, GearSetting.RATIO_6_1, True)\nright_motor_b = Motor(Ports.PORT12, GearSetting.RATIO_6_1, True)\nright_motor_c = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\nright_drive_smart = MotorGroup(right_motor_a, right_motor_b, right_motor_c)\ndrivetrain = DriveTrain(left_drive_smart, right_drive_smart, wheelTravel, trackWidth, wheelBase, MM, externalGearRatio)\n\"\"\"\ndrivetrain.set_stopping(COAST)\ndrivetrain.set_drive_velocity(100, PERCENT)\ndrivetrain.set_turn_velocity(100, PERCENT)\n\n\"\"\"\n+===================================+\n|                                   |\n|       Custom Math Functions       |\n|                                   |\n+===================================+\n\"\"\"\nimport math\npi = math.pi\n\ndef custom_round(value, threshold, epsilon=1e-10):\n    scaled = value / threshold\n    frac = abs(scaled) - abs(int(scaled))\n    if abs(frac - 0.5) < epsilon:\n        result = math.floor(abs(scaled)) * threshold\n    else:\n        result = round(abs(scaled)) * threshold\n    return math.copysign(result, value)\n\ndef joystick_response_curve(x, blend=0.6, exponent=1.5, input_max=100.0):\n    if x == 0:\n        return 0.0\n    sign = 1 if x > 0 else -1\n    normalized = abs(x) / input_max\n    curved = normalized ** (exponent - 1)\n    blended = (1 - blend) + (blend * curved)\n    return sign * input_max * normalized * blended\n\ndef weighted_average(self, values, weights=None):\n    if not values:\n        return 0.0\n    if weights is None:\n        return sum(values) / len(values)\n    weighted_sum = sum(v * w for v, w in zip(values, weights))\n    total_weight = sum(weights)\n    return weighted_sum / total_weight if total_weight != 0 else sum(values) / len(values)\n\n\"\"\"\n+===================================+\n|                                   |\n|           Radio Control           |\n|                                   |\n+===================================+\n\"\"\"\ndrive = {\n    'L': {'motor': left_drive_smart, 'prev': 0},\n    'R': {'motor': right_drive_smart, 'prev': 0}\n}\nremote_control_code_enabled = True\naccel_limit = 25\ndeadband = 3\ndrive_modes = [\"TANK\", \"ARCADE_LEFT\", \"ARCADE_RIGHT\", \"DOUBLE_ARCADE\", \"SPLIT_LEFT\", \"SPLIT_RIGHT\", \"TWIST\"]  \ncurrent_mode = drive_modes[6]\ncontroller_1_left_shoulder_control_motors_stopped = True\ncontroller_1_right_shoulder_control_motors_stopped = True\n\ndef rc_auto_loop_function_controller_1():\n    global remote_control_code_enabled\n    while True:\n        if remote_control_code_enabled:         \n            a1 = controller_1.axis1.position()\n            a2 = controller_1.axis2.position()\n            a3 = controller_1.axis3.position()\n            a4 = controller_1.axis4.position()\n\n            a1 = joystick_response_curve(a1 if abs(a1) >= deadband else 0)\n            a2 = joystick_response_curve(a2 if abs(a2) >= deadband else 0)\n            a3 = joystick_response_curve(a3 if abs(a3) >= deadband else 0)\n            a4 = joystick_response_curve(a4 if abs(a4) >= deadband else 0)\n\n            if current_mode == \"TANK\": l, r = a3, a2  \n            elif current_mode == \"ARCADE_LEFT\": l, r = a3 + a4, a3 - a4  \n            elif current_mode == \"ARCADE_RIGHT\": l, r = a2 + a1, a2 - a1 \n            elif current_mode == \"DOUBLE_ARCADE\": l, r = (a4 + a3 + a2 + a1) / 2, (a3 + a2 - a1 - a4) / 2   \n            elif current_mode == \"SPLIT_LEFT\": l, r = a3 + a1, a3 - a1  \n            elif current_mode == \"SPLIT_RIGHT\": l, r = a2 + a4, a2 - a4  \n            elif current_mode == \"TWIST\": l, r = a3 + a4, a2 - a1\n            else: l, r = 0, 0\n            \n            for side, target in zip([drive['L'], drive['R']], [l, r]):\n                speed = side['prev'] + max(-accel_limit, min(target - side['prev'], accel_limit))\n                if abs(speed) == 0: side['motor'].stop()\n                else: side['motor'].spin(FORWARD, max(-100, min(speed, 100)), PERCENT)\n                side['prev'] = speed\n\n            if controller_1.buttonL1.pressing():\n                motor_4.spin(FORWARD)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif controller_1.buttonL2.pressing():\n                motor_4.spin(REVERSE)\n                controller_1_left_shoulder_control_motors_stopped = False\n            elif not controller_1_left_shoulder_control_motors_stopped:\n                motor_4.stop()\n                controller_1_left_shoulder_control_motors_stopped = True\n\n            if controller_1.buttonR1.pressing():\n                motor_20.spin(FORWARD)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif controller_1.buttonR2.pressing():\n                motor_20.spin(REVERSE)\n                controller_1_right_shoulder_control_motors_stopped = False\n            elif not controller_1_right_shoulder_control_motors_stopped:\n                motor_20.stop()\n                controller_1_right_shoulder_control_motors_stopped = True    \n        wait(10, MSEC)\n\nrc_auto_loop_function_controller_1 = Thread(rc_auto_loop_function_controller_1)\n\n\"\"\"\n+===================================+\n|                                   |\n|            Time Class             |\n|                                   |\n+===================================+\n\"\"\"\nclass Time:\n    def __init__(self):\n        global brain\n        self.brain = brain\n        self.last_time = self.current_ms()\n        self.start_time = self.last_time\n        self.dt = 0.0\n        \n    def current_ms(self):\n        return self.brain.timer.time(MSEC)\n        \n    def current_sec(self):\n        return self.current_ms() / 1000.0\n        \n    def update(self):\n        self.last_time = self.current_ms()\n\n    def elapsed_ms(self):\n        return (self.current_ms() - self.last_time)\n\n    def elapsed_sec(self):\n        return (self.current_ms() - self.last_time) / 1000.0\n        \n    def reset(self):\n        self.last_time = self.current_ms()\n        self.start_time = self.last_time\n        self.dt = 0.0\n\ndef driver():\n    global drivetrain, controller_1, remote_control_code_enabled\n    while True: \n        if remote_control_code_enabled:\n            pass\n\ndef pre_autonomous():\n    pass\n\ndef autonomous():\n    pass\n\n\"\"\"\n+===================================+\n|                                   |\n|         Competition Setup         |\n|                                   |\n+===================================+\n\"\"\"\npre_autonomous()\ncompetition = Competition(driver, autonomous)\n","textLanguage":"python","robotConfig":[{"port":[6,5,3,2,null],"name":"drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"4-motor","wheelSize":"wheel325in","gear":"ratio6_1","gearRatio":"3:4","direction":"rev","gyroType":"none","width":"260","unit":"mm","wheelbase":"182.5","wheelbaseUnit":"mm","xOffset":"0","xOffsetUnit":"mm","yOffset":"0","yOffsetUnit":"mm","thetaOffset":"180"},"triportSourcePort":null},{"port":[],"name":"controller_1","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","upDown":"","upDownDir":"false","xB":"","xBDir":"false","drive":"none","id":"primary"},"triportSourcePort":22},{"port":[4],"name":"motor_4","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio6_1"},"triportSourcePort":22},{"port":[20],"name":"motor_20","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1","id":"partner"}}],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.12","minVersion":"3.1.0","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}